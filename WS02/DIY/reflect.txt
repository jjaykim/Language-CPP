//==============================================
// Name:           Jungjoo Kim
// Student Number: 162 641 195
// Email:          jkim594@myseneca.ca
// Section:        NCC
// Workshop:       Workshop2_DIY
//==============================================

Through this workshop and class, I could learn what I personally think is the key in C++.
	Firstly, I was able to learn how to use dynamic memory, which is more flexible than static memory and can compile without wasting memory. Unlike static memory, dynamic memory can be allocated as much memory as the user wants or as much as the data has size. For example, in this LAB workshop, when I input the employee name in CSV file through "fscanf", I received it using "char name[128]" because I don't know the size of the employee name. This number 128 is a randomly specified size, and even if the size of the employee's name is smaller than 128, I have to use 128bites. This will be a waste of memory.
	However, when I knew the number of records in the file and the size of the employee's name, I only had to allocate the corresponding number of memory using "new". "new" can enter the type and size that you want to assign to a pointer-type variable. For example, "employees = new Employee[noOfEmployees]" or "emp.m_name = new char[strLen(name) + 1]". It is important to note that when assigning a character array, I must assign one more space than the string size. The reason is to enter a null value at the end.
	Finally, most importantly, if I allocated dynamic memory, I must delete the memory that I allocated before terminating. If memory is not deleted, a memory leak error will occur. I use "delete[]' to delete dynamic memory such as "delete[] employees[i].m_name" and "delete[] employees". In addition, when deleting memory, it is necessary to delete the memory in the reverse order of the order in which it was initially allocated. This is because, in this workshop, I dyanamically allocated an array of employees into Employee pointer, then allocated to each employee array for name size. However, if I delete the array of employees first, the compiler cannot find the memory allocated to the character array when deleting it, which causes a memory leak. It is also important to make a habit of deleting memory and assigning "nullptr" to the address value to prevent the last deleted memory address from being deleted twice in advance.

It was hard for me to understand the overload of the functions in detail at first. So I ran into difficulties to figure out which parameters to use while doing my assignment. However, I was able to overcome the difficulties by identifying what overloaded functions should return or what tasks to perform. First of all, overload means that several functions use the same name as each other. This is possible in C++ because the compiler of C++ determines that the functions are different if they have different parameters, even if they have the same name. The process of a compiler finding an overloaded function first searches for matching parameters, and if it cannot find a matching overloading function, the compiler searches for a specific function that can be cast type through several stages. However, even in this process, if no matching function is found, or if two or more functions are found that can be cast, the compiler determines that they are ambiguous, causing errors. 
	Moreover, during this workshop, I had time to implement several overload functions. At this time, I used parameters like "bool load(Employee& emp)", “bool read(char *empName)” or "void display (const Employee& emp)" to overload functions. I used "out parameters" more than "in parameters" in this workshop. The out parameter is passed through a reference(&) or pointer(*), not through a value or constant. When a parameter is received as an out parameter, the function can be used by copying the value of the parameter, as well as overwriting the value of the parameter. This is due to direct access to the addresses of the parameters. Thus, these changed values can be useful for all other functions as well as their corresponding functions. However, there are also an "in parameters" that the function can receive. The in parameter is a parameter that prevents the value of the parameter from being modified and can only be read, which is expressed using the keyword "IN" and "const" keyword. In conclusion, the out parameters and an in parameters differ in whether the function can change the values of the parameters it receives as factors. I can distinguish between an out parameter and an in parameter through a keyword, and if I receive a parameter with a reference(&) or pointer(*), the parameter is an out parameter, and if I receive a parameter with a "const" or "in" keyword, the parameter is an in parameter.
